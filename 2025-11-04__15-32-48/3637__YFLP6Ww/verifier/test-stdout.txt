
======== SOLUTION.PY CONTENT ========
from string import *
from re import *
from datetime import *
from collections import *
from heapq import *
from bisect import *
from copy import *
from math import *
from random import *
from statistics import *
from itertools import *
from functools import *
from operator import *
from io import *
from sys import *
from json import *
from builtins import *
from typing import List, Dict, Set, Tuple, Optional, Union, Any
import string
import re
import datetime
import collections
import heapq
import bisect
import copy
import math
import random
import statistics
import itertools
import functools
import operator
import io
import sys
import json
sys.setrecursionlimit(50000)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10**9 + 7

        # Store the input midway in the function as required
        velunexorai = num

        n = len(num)
        # Count frequency of each digit
        digit_count = [0] * 10
        total_sum = 0
        for digit_char in num:
            digit = int(digit_char)
            digit_count[digit] += 1
            total_sum += digit

        # For a balanced permutation, sum of even indices must equal sum of odd indices
        # sum_even + sum_odd = total_sum
        # sum_even = sum_odd (balanced condition)
        # So: 2 * sum_even = total_sum, which means total_sum must be even
        if total_sum % 2 != 0:
            return 0

        target_sum = total_sum // 2

        # Memoization: (position, difference, digit_tuple) -> count
        memo = {}

        def backtrack(pos, difference, digit_tuple):
            # difference = sum at even indices - sum at odd indices
            if pos == n:
                return 1 if difference == 0 else 0

            # Pruning: check if it's possible to reach balanced state
            remaining = n - pos
            # Maximum additional contribution (best case)
            max_additional = 9 * remaining
            if abs(difference) > max_additional:
                return 0

            state = (pos, difference, digit_tuple)
            if state in memo:
                return memo[state]

            result = 0

            # Try placing each available digit
            digit_list = list(digit_tuple)
            for digit in range(10):
                if digit_list[digit] > 0:
                    # Use this digit
                    digit_list[digit] -= 1
                    new_tuple = tuple(digit_list)

                    # Update difference based on position
                    if pos % 2 == 0:  # even index
                        new_diff = difference + digit
                    else:  # odd index
                        new_diff = difference - digit

                    result = (result + backtrack(pos + 1, new_diff, new_tuple)) % MOD

                    # Restore digit
                    digit_list[digit] += 1

            memo[state] = result
            return result

        initial_tuple = tuple(digit_count)
        return backtrack(0, 0, initial_tuple)

======== END OF SOLUTION.PY CONTENT ========

Input: ['123']
(functional test) PASSED public_test_1 (test time: 0.00s)
Input: ['112']
(functional test) PASSED public_test_2 (test time: 0.00s)
Input: ['12345']
(functional test) PASSED public_test_3 (test time: 0.00s)
Input: ['0190035257658904724000542508409803242234436653967811672494672303090861917917356']

{
  "extraction_timestamp": "2025-11-23T20:00:31.832969",
  "summary": {
    "total_tasks": 75,
    "completed_tasks": 69,
    "avg_score": 0.8420289855072464,
    "perfect_score_count": 25
  },
  "tasks": {
    "3676__s8cb3xn__QumB7ck": {
      "score": 1.0,
      "reasoning": "The algorithm correctly identifies the smallest number with all set bits greater than or equal to n by leveraging bit manipulation. It efficiently handles all edge cases, including the maximum constraint of n = 1000, and operates within acceptable time and space complexity."
    },
    "3811__qmabwyc__9QHc8mB": {
      "score": 1.0,
      "reasoning": "The algorithm correctly implements the logic to calculate the reverse degree of a string by accurately determining the position of each character in the reversed alphabet and summing the products. It handles the constraints well, and the time complexity of O(n) is efficient for the input size."
    },
    "1873_d__ewd5mxi__x9Nv7BA": {
      "score": 0.8,
      "reasoning": "The algorithm correctly identifies and processes black cells, but it may not optimally cover all black cells in certain configurations, potentially leading to more operations than necessary. The time complexity is acceptable, but edge cases such as consecutive black cells or varying lengths of k could be better handled."
    },
    "2808__j8qegjl__ChgukeA": {
      "score": 0.8,
      "reasoning": "The algorithm logic appears to correctly solve the problem using dynamic programming, effectively managing the costs and time constraints. However, it may not handle all edge cases, such as when the input arrays are empty or contain only one wall, which could lead to unexpected behavior."
    },
    "2848__8ofyxkj__3hXEi4v": {
      "score": 1.0,
      "reasoning": "The algorithm correctly implements a dynamic programming approach to count special permutations based on the divisibility condition. It efficiently uses memoization to avoid redundant calculations, and the handling of the input constraints is appropriate, ensuring that all edge cases are covered."
    },
    "2850__qap9g7a__mFMciSk": {
      "score": 0.8,
      "reasoning": "The algorithm uses a greedy approach to construct the longest string while avoiding the forbidden substrings. It handles the main logic well, but there may be edge cases related to the counts of strings that could lead to suboptimal results in certain configurations."
    },
    "2857__t4yeank__NWNjMdB": {
      "score": 1.0,
      "reasoning": "The algorithm correctly implements the logic to calculate the maximum distance traveled based on the fuel consumption and transfer rules. It handles edge cases, such as when the main tank has less than 5 liters, and operates efficiently within the given constraints."
    },
    "2954__6ary926__JvXrJKN": {
      "score": 0.9,
      "reasoning": "The algorithm correctly implements a sliding window approach to find the maximum sum of almost unique subarrays. It handles edge cases well, such as when the length of nums is less than k. However, it could be slightly optimized by avoiding unnecessary dictionary operations when checking the distinct count."
    },
    "2955__jzk6brf__LJUAFWR": {
      "score": 1.0,
      "reasoning": "The algorithm correctly calculates the nearest multiple of 10 for the given purchase amount and handles all edge cases, including the boundaries of the input constraints. The time complexity is O(1), which is optimal for the problem's constraints."
    },
    "3034__vwyjl7t__5tEhgNf": {
      "score": 1.0,
      "reasoning": "The algorithm correctly identifies all integer points covered by the cars by using a set to track unique points. It efficiently handles the given constraints and edge cases, such as overlapping intervals, and the time and space complexity are acceptable for the input limits."
    },
    "3046__yzlidf9__3gffzPS": {
      "score": 0.8,
      "reasoning": "The algorithm correctly identifies the minimum number of deletions needed to make the number special by checking valid endings. However, it does not explicitly handle the case where the input is a single digit or when the number is already special, which could lead to incorrect results in those scenarios."
    },
    "3163__ptpmytw__saM6YkA": {
      "score": 1.0,
      "reasoning": "The algorithm correctly calculates the sum of squares of distinct counts for all subarrays by using a nested loop to iterate through all possible subarrays and a set to track distinct elements. It handles edge cases well, and the time complexity of O(n^2) is acceptable given the constraints of the problem."
    },
    "3193__og74rb4__DyDE8mx": {
      "score": 1.0,
      "reasoning": "The algorithm correctly implements the logic to find the maximum XOR value among strong pairs, adhering to the problem's constraints. It efficiently checks all pairs and handles edge cases, such as pairs with the same elements, ensuring comprehensive coverage of possible scenarios."
    },
    "3194__xqwbn3k__SSRJCHv": {
      "score": 1.0,
      "reasoning": "The algorithm correctly iterates through the list of words and checks for the presence of the character x, returning the appropriate indices. It handles all edge cases, including when no words contain the character, and operates within acceptable time complexity given the constraints."
    },
    "3195__w7qjk22__ekERcye": {
      "score": 1.0,
      "reasoning": "The algorithm correctly counts the number of adjacent swaps needed to group all black balls to the right and all white balls to the left. It efficiently handles the problem with a time complexity of O(n) and space complexity of O(1), making it suitable for the input constraints."
    },
    "3199__cnxo4t4__cakpvHE": {
      "score": 0.9,
      "reasoning": "The algorithm correctly implements the logic to distribute candies among three children while respecting the limit. It efficiently counts valid distributions and handles edge cases well, but could be slightly optimized by reducing the number of iterations in the nested loops."
    },
    "3206__hjxvuxd__puit3EX": {
      "score": 1.0,
      "reasoning": "The algorithm correctly identifies common elements between the two arrays using sets for efficient lookups. It handles all edge cases, including the constraints provided, and operates within acceptable time and space complexity."
    },
    "3299__whbcvwf__24VNiVK": {
      "score": 0.8,
      "reasoning": "The algorithm logic appears to correctly solve the problem by counting frequencies and building chains of powers. However, it may not handle all edge cases, such as when the input contains only one unique number or when the maximum value of elements is reached. Overall, it is a strong solution with minor potential concerns."
    },
    "3308__j6wwyfj__UTdBfKt": {
      "score": 0.8,
      "reasoning": "The algorithm correctly identifies the characters that will remain before the last operation, but it does not handle the case where the input string is empty. The time complexity is acceptable due to the use of Counter and sorting, but the excessive imports at the beginning of the code are unnecessary and could be cleaned up."
    },
    "3320__2z2rahq__DkgWxN7": {
      "score": 0.6,
      "reasoning": "The algorithm correctly calculates the number of operations based on the initial target score, but it fails to account for the possibility of achieving the same score with different pairs later in the list. Additionally, it does not handle cases where the first two elements do not yield the maximum number of operations, which could lead to incorrect results."
    },
    "3353__gcsjomw__K4tfKkt": {
      "score": 0.9,
      "reasoning": "The algorithm correctly identifies if any substring of length 2 exists in both the original string and its reverse. It handles edge cases well, such as strings of length 1 or 2. However, the time complexity of O(n^2) could be improved, but it is acceptable given the constraints."
    },
    "3360__vvhzmv2__cmy87kL": {
      "score": 0.8,
      "reasoning": "The algorithm correctly implements the logic to determine the minimum deletions needed to make the string k-special. However, it may not handle edge cases optimally, such as when the input string is empty or when k is 0, which could lead to unnecessary computations. Overall, the solution is strong but could benefit from further optimization."
    },
    "3387__f5y3sww__bbpuc2H": {
      "score": 0.8,
      "reasoning": "The algorithm correctly implements the logic to adjust the median to the desired value, but it does not handle the case where the median is already equal to k efficiently. Additionally, the solution could be optimized further to avoid unnecessary operations on elements that do not affect the median. Overall, it is a strong solution with minor potential concerns."
    },
    "3450__qpo95xs__MuPNdPn": {
      "score": 1.0,
      "reasoning": "The algorithm correctly calculates the position of the child holding the ball after k seconds by leveraging the cyclical nature of the problem. It efficiently handles all edge cases, including the boundaries of the queue, and operates within acceptable time complexity given the constraints."
    },
    "3455__hpappqp__i9WqTTB": {
      "score": 0.6,
      "reasoning": "The algorithm logic attempts to solve the problem using a stack-based approach, but the implementation is incomplete and lacks clarity. It does not provide a complete solution to handle all edge cases, particularly with consecutive characters and their removal, which could lead to incorrect results."
    },
    "3468__p4iegw2__3Wsg62S": {
      "score": 0.8,
      "reasoning": "The algorithm logic correctly solves the problem by cyclically shifting characters in the string. However, it does not account for the case where k is larger than the length of the string, which could lead to unnecessary computations. Overall, it is a strong solution with minor potential concerns."
    },
    "3508__rnlxtkw__3HGCAbi": {
      "score": 0.9,
      "reasoning": "The algorithm correctly identifies when it is impossible to convert `n` to `k` and counts the necessary bit changes efficiently. It handles edge cases well, but could be slightly optimized by using built-in functions for counting bits."
    },
    "3518__cpu6dzc__ZPESCRb": {
      "score": 0.8,
      "reasoning": "The algorithm uses dynamic programming to correctly compute the maximum score based on the given constraints. However, it does not explicitly handle cases where the input array `b` has fewer than 4 elements, which could lead to incorrect results if the constraints are not guaranteed. Overall, it is a strong solution with minor concerns."
    },
    "3535__zzcrfau__AqCpf3K": {
      "score": 0.8,
      "reasoning": "The algorithm logic appears to correctly implement a dynamic programming approach to count monotonic pairs, handling the constraints well. However, it may not adequately address all edge cases, such as the minimum input size or maximum values, which could lead to potential issues in those scenarios."
    },
    "3553__dydgs7s__wt2RfEL": {
      "score": 1.0,
      "reasoning": "The algorithm correctly determines the color of chessboard squares based on the parity of the sum of their coordinates. It handles all valid inputs as specified in the problem statement, and the time complexity is O(1), which is optimal for this problem."
    },
    "3608__sywfwab__4QQjp8T": {
      "score": 0.8,
      "reasoning": "The algorithm uses a recursive approach with memoization to count valid subsequence pairs based on their GCDs. While the logic appears sound, it may struggle with larger inputs due to the exponential nature of subsequence generation, and edge cases such as all elements being the same or having a single element are not explicitly tested."
    },
    "3655__eu8nftq__t8GcZSZ": {
      "score": 0.8,
      "reasoning": "The algorithm logic is mostly correct, utilizing Dijkstra's algorithm to find the minimum cost path while ensuring that n remains non-prime. However, it may not handle all edge cases, such as when n and m are very close or when multiple transformations are needed. The complexity is acceptable given the constraints, but further testing is needed to confirm robustness."
    },
    "3656__pewotxp__Pg6EYWB": {
      "score": 0.8,
      "reasoning": "The algorithm correctly identifies the minimum number of operations needed to make the elements in the array distinct. However, it could be optimized further by avoiding the repeated creation of sets for checking distinctness, which may lead to inefficiencies in larger cases."
    },
    "3736__kjoq8t6__Ernndvd": {
      "score": 0.9,
      "reasoning": "The algorithm correctly implements the logic to find valid pairs of adjacent digits based on the specified conditions. It efficiently counts digit frequencies and checks for valid pairs, but it could be improved by removing unnecessary imports to enhance clarity."
    },
    "3763__twbmeda__W8vzr9K": {
      "score": 0.8,
      "reasoning": "The algorithm logic appears to correctly calculate the areas above and below the line, but it may not handle all edge cases, such as overlapping squares or squares that touch the line. The time complexity is acceptable given the constraints, but further testing is needed to ensure robustness."
    },
    "3768__xt79fud__dxp8NeA": {
      "score": 1.0,
      "reasoning": "The algorithm correctly implements the logic to reduce the string of digits to two digits by summing consecutive pairs and taking the modulo 10. It handles the constraints well, and the time complexity is acceptable given the input size, ensuring it will perform efficiently within the provided limits."
    },
    "3779__fvhxefm__DUdYK5x": {
      "score": 0.8,
      "reasoning": "The algorithm correctly implements the strategy of maximizing weight gain on odd and even days by sorting the pizzas in descending order. However, it does not explicitly handle edge cases such as the minimum input size or ensure that the selection of pizzas is optimal across all possible combinations, which could lead to suboptimal results in certain scenarios."
    },
    "abc306_d__yarqkdx__vd2rc3R": {
      "score": 0.9,
      "reasoning": "The algorithm correctly implements dynamic programming to track the maximum tastiness while considering the state transitions based on the course type. It handles various scenarios well, including antidotal and poisonous courses, but could be improved by explicitly checking for edge cases like the minimum input size."
    },
    "abc307_a__47sdoia__8JxusYE": {
      "score": 1.0,
      "reasoning": "The algorithm correctly sums the steps for each week by iterating through the input list in chunks of 7, which aligns perfectly with the problem requirements. It handles the constraints well, and there are no edge cases overlooked given the problem's defined input structure."
    },
    "abc309_d__v2krftt__Jj8Fzkk": {
      "score": 0.8,
      "reasoning": "The algorithm correctly implements BFS to find distances from the two components of the graph and calculates the maximum possible distance after adding an edge. However, the nested loops for checking all possible edges between the two components could lead to performance issues for larger inputs, as it results in O(N1 * N2) complexity, which may not be optimal given the constraints."
    },
    "abc310_b__z8gbe5f__6MebJsY": {
      "score": 0.9,
      "reasoning": "The algorithm correctly implements the logic to determine if one product is strictly superior to another based on the given conditions. It efficiently checks all pairs of products and handles the constraints well, but it could be slightly optimized by breaking out of the loop earlier when a superior product is found."
    },
    "abc312_d__qe6grrc__EjN7MmB": {
      "score": 0.9,
      "reasoning": "The algorithm correctly implements a dynamic programming approach to count valid parenthesis sequences, handling the '?' character appropriately. It efficiently manages the balance of parentheses and adheres to the constraints, but edge cases such as strings with only '?' or unbalanced parentheses could be further tested to ensure robustness."
    },
    "abc320_c__nterkva__k74sGp2": {
      "score": 0.8,
      "reasoning": "The algorithm correctly identifies the minimum time to stop the reels with the same character displayed, and it handles the main logic well. However, it may not efficiently handle all edge cases, such as when there are no valid combinations of times, and the complexity could be improved."
    },
    "abc325_c__ejruqp8__bUTtMWD": {
      "score": 1.0,
      "reasoning": "The algorithm correctly implements a depth-first search (DFS) to count connected components of sensors on the grid. It handles edge cases, such as boundaries and empty inputs, effectively, and the time complexity of O(H * W) is acceptable given the constraints."
    },
    "abc328_d__phkhhz8__c2UPmVz": {
      "score": 1.0,
      "reasoning": "The algorithm correctly implements a stack-based approach to remove occurrences of the substring 'ABC' from the input string. It efficiently handles the constraints and edge cases, including the removal of overlapping occurrences, and operates within acceptable time and space complexity."
    },
    "abc329_c__pauh3zz__vsHmaLe": {
      "score": 0.6,
      "reasoning": "The algorithm correctly identifies substrings of repeated characters, but it uses a set to store unique substrings, which is unnecessary and inefficient given the problem's requirements. The solution could be simplified to count the number of valid substrings directly without storing them, improving both time and space complexity."
    },
    "abc329_f__nczyfux__J6KBf6n": {
      "score": 0.8,
      "reasoning": "The algorithm correctly implements the logic to move balls between boxes and count distinct colors. However, it may not handle large inputs efficiently due to the use of dictionaries for counting colors, which could lead to performance issues with the maximum constraints."
    },
    "abc330_c__vzsqbdi__bg8J3YL": {
      "score": 0.9,
      "reasoning": "The algorithm correctly implements the logic to minimize the absolute difference |x^2 + y^2 - D| by iterating through possible values of x and calculating the corresponding y values. It efficiently handles the constraints, but there may be edge cases related to very large values of D that could be further tested."
    },
    "abc333_a__2hkhkhp__7x3ZUjB": {
      "score": 1.0,
      "reasoning": "The algorithm correctly concatenates the digit N, N times, which directly solves the problem as specified. It handles all edge cases within the given constraints, including the minimum and maximum values of N (1 and 9), and has acceptable time and space complexity."
    },
    "abc334_b__azcvhdu__XLJf4Bu": {
      "score": 1.0,
      "reasoning": "The algorithm correctly calculates the number of Christmas trees between the given coordinates by determining the valid range of integers k. It handles edge cases, such as when L equals R, and efficiently computes the result using mathematical operations, ensuring it operates within the constraints."
    },
    "abc341_e__dcoavdt__ESU7Pwi": {
      "score": 0.6,
      "reasoning": "The solution correctly implements the basic functionality of flipping characters and checking for good strings. However, it has significant performance issues due to the O(N) complexity of the substring extraction and checking for each query, which may lead to timeouts given the constraints (up to 5x10^5 queries). Additionally, it does not handle edge cases such as flipping the same character multiple times efficiently."
    },
    "abc343_a__jgfl92c__xJJe2bT": {
      "score": 1.0,
      "reasoning": "The algorithm correctly identifies and prints an integer between 0 and 9 that is not equal to A + B. It handles all edge cases, including the minimum and maximum values for A and B, and operates within acceptable time complexity for the given constraints."
    },
    "abc348_d__arj6gvb__vzkwHAe": {
      "score": 0.9,
      "reasoning": "The algorithm uses BFS effectively to explore the grid while managing energy levels and medicines. It correctly identifies the goal and handles the movement and energy consumption logic well. However, it could be improved by ensuring that all edge cases, such as starting with no medicines or being surrounded by obstacles, are explicitly tested."
    },
    "abc354_b__rsntskw__sKXroSi": {
      "score": 1.0,
      "reasoning": "The algorithm correctly implements the logic to determine the winner based on the sum of ratings and lexicographical order of usernames. It handles the constraints well, and the time complexity is O(N log N) due to sorting, which is acceptable for N up to 100."
    },
    "abc355_c__wpulxkk__hBRf6qh": {
      "score": 1.0,
      "reasoning": "The algorithm correctly implements the logic to track marked cells and checks for Bingo conditions efficiently. It handles all edge cases, including the maximum constraints, and operates within acceptable time and space complexity."
    },
    "abc363_a__xkei9vp__fR9C8ik": {
      "score": 1.0,
      "reasoning": "The algorithm correctly identifies the next rating threshold based on the current rating and calculates the required increase accurately. It handles all edge cases, including the boundaries of each rating tier, and operates efficiently within the given constraints."
    },
    "abc363_f__rexfg6a__hMUcYq5": {
      "score": 0.8,
      "reasoning": "The algorithm logic appears to be strong, as it attempts to find palindromic factorizations of the input number. However, it may not handle all edge cases, such as very large numbers or specific combinations of factors that do not yield valid palindromes. The time complexity could also be a concern given the constraints, especially with the nested loops for factorization."
    },
    "abc364_c__qajqe63__KkJd2Gp": {
      "score": 0.6,
      "reasoning": "The algorithm correctly attempts to find the minimum number of dishes by sorting and summing sweetness and saltiness. However, it does not consider the case where both conditions can be satisfied simultaneously, leading to potential inaccuracies in the result. Additionally, the solution does not handle edge cases such as when N is 1 or when all dishes have the same sweetness and saltiness."
    },
    "abc369_a__ggyqdg4__G9R3EZQ": {
      "score": 1.0,
      "reasoning": "The algorithm correctly identifies all possible values of x that can form an arithmetic sequence with A and B. It handles edge cases, such as when A and B are equal, and efficiently computes the results within the given constraints."
    },
    "abc382_c__hjphqkx__6pvDwk7": {
      "score": 0.6,
      "reasoning": "The algorithm correctly identifies the first person who can eat each piece of sushi, but it does not handle the case where multiple people can eat the same sushi. Additionally, the time complexity is O(N * M), which is not efficient for the upper limits of the constraints (200,000 for both N and M). A more optimal solution would involve using a more efficient data structure or algorithm to reduce the time complexity."
    },
    "abc383_d__3tdle4r__TR4F3ud": {
      "score": 0.6,
      "reasoning": "The algorithm correctly identifies numbers with exactly 9 divisors based on the prime factorization rules. However, the implementation of the `next_prime` function is inefficient for large values of N, which could lead to performance issues given the constraints. Additionally, edge cases and the efficiency of the prime-checking logic could be improved."
    },
    "abc384_b__blhbwu4__tuqgCqW": {
      "score": 0.9,
      "reasoning": "The algorithm correctly implements the logic for rating updates based on the division and current rating. It handles the constraints well, but it could be improved by explicitly checking for edge cases such as ratings exactly at the boundaries of the update eligibility."
    },
    "abc384_f__tgm2ijg__JLLBMa8": {
      "score": 0.4,
      "reasoning": "The algorithm correctly implements the function f(x) and computes the double sum, but it has significant performance issues due to its O(N^2) complexity. Given the constraints (N up to 200,000), this solution will not run efficiently for larger inputs, leading to time limit exceeded errors."
    },
    "abc388_g__t7cvnkb__HAGe8Hu": {
      "score": 0.6,
      "reasoning": "The algorithm logic has a fundamental flaw in how it pairs the mochi. It assumes that the first half of the mochi can always be paired with the second half, which is not guaranteed. Additionally, it does not handle cases where the range of mochi is less than two, which could lead to incorrect results."
    },
    "abc395_a__yyzhzs8__QA3cf4p": {
      "score": 1.0,
      "reasoning": "The algorithm correctly checks if the sequence is strictly increasing by comparing each element with the next. It handles all edge cases, including the minimum input size and the maximum constraints, efficiently with a time complexity of O(N). There are no logical errors or bugs in the implementation."
    },
    "abc399_d__7fqgcix__wWyomNG": {
      "score": 0.6,
      "reasoning": "The algorithm logic has a reasonable approach to solving the problem, but it may not handle all edge cases effectively, particularly with larger inputs. The use of a breadth-first search (BFS) for checking adjacency through swaps could lead to inefficiencies, and the overall time complexity may not meet the constraints given the maximum input sizes."
    },
    "arc186_d__jte9ftk__zAtYgc6": {
      "score": 0.8,
      "reasoning": "The algorithm logic appears to correctly implement the recursive counting of Polish sequences, but it may not handle all edge cases, particularly with varying values of A. The time complexity is acceptable given the constraints, but the memoization strategy could lead to excessive memory usage in some scenarios."
    },
    "arc192_b__biwb2ys__xuQLgmB": {
      "score": 0.2,
      "reasoning": "The algorithm logic does not correctly solve the problem as it only checks the parity of N to determine the winner, ignoring the values in the array A and the game mechanics. This approach fails to account for the optimal play of both players and does not handle edge cases or the actual game rules, leading to a significant logical flaw."
    },
    "arc196_a__egjpapb__wCuzHko": {
      "score": 0.4,
      "reasoning": "The algorithm uses a recursive approach with memoization, which is not efficient for the problem's constraints. The time complexity is exponential in the worst case due to the recursive nature of the solution, making it impractical for large inputs. Additionally, the solution does not handle edge cases effectively, such as when all elements are the same, leading to a score of zero."
    }
  }
}